#pragma once

#include "dev/pci.h"
#include "stdio.h"

#define SATA_SIG_ATA   0x00000101
#define SATA_SIG_ATAPI 0xEB140101
#define SATA_SIG_SEMB  0xC33C0101
#define SATA_SIG_PM    0x96690101

#define AHCI_DEV_NULL   0
#define AHCI_DEV_SATA   1
#define AHCI_DEV_SATAPI 2
#define AHCI_DEV_SEMB   3
#define AHCI_DEV_PM     4

#define HBA_PORT_IPM_ACTIVE  1
#define HBA_PORT_DET_PRESENT 3

enum {
	AHCI_FIS_TYPE_REG_H2D	= 0x27,	// Register FIS - host to device
	AHCI_FIS_TYPE_REG_D2H	= 0x34,	// Register FIS - device to host
	AHCI_FIS_TYPE_DMA_ACT	= 0x39,	// DMA activate FIS - device to host
	AHCI_FIS_TYPE_DMA_SETUP	= 0x41,	// DMA setup FIS - bidirectional
	AHCI_FIS_TYPE_DATA		= 0x46,	// Data FIS - bidirectional
	AHCI_FIS_TYPE_BIST		= 0x58,	// BIST activate FIS - bidirectional
	AHCI_FIS_TYPE_PIO_SETUP	= 0x5F,	// PIO setup FIS - device to host
	AHCI_FIS_TYPE_DEV_BITS	= 0xA1,	// Set device bits FIS - device to host
};

struct ahci_fis_h2d
{
	// DWORD 0
	volatile uint8_t  fis_type;	// FIS_TYPE_REG_H2D
 
	volatile uint8_t  pmport : 4;	// Port multiplier
	volatile uint8_t  rsv0 : 3;		// Reserved
	volatile uint8_t  c : 1;		// 1: Command, 0: Control
 
	volatile uint8_t  command;	// Command register
	volatile uint8_t  featurel;	// Feature register, 7:0
 
	// DWORD 1
	volatile uint8_t  lba0;		// LBA low register, 7:0
	volatile uint8_t  lba1;		// LBA mid register, 15:8
	volatile uint8_t  lba2;		// LBA high register, 23:16
	volatile uint8_t  device;		// Device register
 
	// DWORD 2
	volatile uint8_t  lba3;		// LBA register, 31:24
	volatile uint8_t  lba4;		// LBA register, 39:32
	volatile uint8_t  lba5;		// LBA register, 47:40
	volatile uint8_t  featureh;	// Feature register, 15:8
 
	// DWORD 3
	volatile uint8_t  countl;		// Count register, 7:0
	volatile uint8_t  counth;		// Count register, 15:8
	volatile uint8_t  icc;		// Isochronous command completion
	volatile uint8_t  control;	// Control register
 
	// DWORD 4
	volatile uint8_t  rsv1[4];	// Reserved
} __attribute((packed));


struct ahci_hba_port_struct {
    volatile uint64_t clb;
    volatile uint64_t fb;

    volatile uint32_t is;
    volatile uint32_t ie;
    volatile uint32_t cmd;
    volatile uint32_t rsv0;

    volatile uint32_t tfd;
    volatile uint32_t sig;
    volatile uint32_t ssts;
    volatile uint32_t sctl;
    volatile uint32_t serr;
    volatile uint32_t sact;

    volatile uint32_t ci;
    volatile uint32_t sntf;
    volatile uint32_t fbs;

    volatile uint32_t rsv1[11];
    volatile uint32_t vendor[4];
} __attribute((packed));

struct ahci_hba_struct {
    volatile uint32_t cap;
    volatile uint32_t ghc;
    volatile uint32_t is;
    volatile uint32_t pi;
    volatile uint32_t vs;

    volatile uint32_t ccc_ctl;
    volatile uint32_t ccc_pts;

    volatile uint32_t en_loc;
    volatile uint32_t en_ctl;

    volatile uint32_t cap2;
    volatile uint32_t bohc;

	volatile uint8_t rsv[0xA0 - 0x2C];

    volatile uint8_t vendor[0x100 - 0xA0];

    volatile struct ahci_hba_port_struct ports[32];
} __attribute((packed));

struct ahci_command_header {
	volatile uint8_t cfl : 5;
	volatile uint8_t a : 1;
	volatile uint8_t w : 1;
	volatile uint8_t p : 1;

	volatile uint8_t r : 1;
	volatile uint8_t b : 1;
	volatile uint8_t c : 1;
	volatile uint8_t rsv0 : 1;
	volatile uint8_t pmp  : 4;

	volatile uint16_t prdtl;

	volatile uint32_t prdbc;

	volatile uint64_t ctba;

	volatile uint32_t rsv1[4];
} __attribute((packed));

struct ahci_prdt_entry {
	volatile uint64_t dba;
	volatile uint32_t rsv0;
 
	volatile uint32_t dbc  : 22;
	volatile uint32_t rsv1 :  9;
	volatile uint32_t i    :  1;
} __attribute((packed));

struct ahci_command_table {
    volatile uint8_t cfis[64];
    volatile uint8_t acmd[16];
    volatile uint8_t rsvd[48];

    volatile struct ahci_prdt_entry prdt[8];
} __attribute((packed));


struct ahci_dev {
    uint8_t type;
    
    struct ahci_command_header* command_headers; // Command list structure pointer
    struct ahci_command_table*  command_tables;

    void* tx_fis[32]; // Sending FIS structure virtual addr pointers
    void* rx_fis;     // Receiving FIS structure virtual addr pointer
    
    struct ahci_hba_port_struct* port;
    //void* data;
};

volatile struct ahci_hba_struct* ahci_hba;

pci_entry_t* ahci_controller;
pci_address_t ahci_address;
void* ahci_bar;

struct ahci_dev ahci_devs[32];
uint8_t ahci_dev_amount;
uint8_t ahci_max_commands;

void* ahci_common;


uint16_t ahci_probe_port(volatile struct ahci_hba_port_struct* port) {

    uint32_t ssts = port->ssts;

    uint8_t ipm = (ssts >> 8) & 0x0F;
    uint8_t det = ssts & 0x0F;

    if (det != HBA_PORT_DET_PRESENT || ipm != HBA_PORT_IPM_ACTIVE)
        return AHCI_DEV_NULL;

    switch (port->sig) {
        case SATA_SIG_ATAPI:
            return AHCI_DEV_SATAPI;
        case SATA_SIG_SEMB:
            return AHCI_DEV_SEMB;
        case SATA_SIG_PM:
            return AHCI_DEV_PM;
        default:
            return AHCI_DEV_SATA;
    }
}

void ahci_count_devs() {

    uint32_t pi = ahci_hba->pi;
    
    for (int i = 0; i < 32; i++) {

        if (!(pi & (1 << i)))
            continue;

        if ((i + 1) > ahci_dev_amount)
            ahci_dev_amount = i + 1;
    }
}


#define HBA_PxCMD_ST    0x0001
#define HBA_PxCMD_FRE   0x0010
#define HBA_PxCMD_FR    0x4000
#define HBA_PxCMD_CR    0x8000

// Start command engine
void start_cmd(volatile struct ahci_hba_port_struct* port)
{
	// Wait until CR (bit15) is cleared
	while (port->cmd & HBA_PxCMD_CR)
		;
 
	// Set FRE (bit4) and ST (bit0)
	port->cmd |= HBA_PxCMD_FRE;
	port->cmd |= HBA_PxCMD_ST; 
}
 
// Stop command engine
void stop_cmd(volatile struct ahci_hba_port_struct* port)
{
	// Clear ST (bit0)
	port->cmd &= ~HBA_PxCMD_ST;
 
	// Wait until FR (bit14), CR (bit15) are cleared
	while (true) {
		if (port->cmd & HBA_PxCMD_FR)
			continue;
		if (port->cmd & HBA_PxCMD_CR)
			continue;

		break;
	}
 
	// Clear FRE (bit4)
	port->cmd &= ~HBA_PxCMD_FRE;
}

int ahci_wait_for_completion(int dev, int slot) {

    struct ahci_hba_port_struct* port = ahci_devs[dev].port;

    if (slot == -1)
        return -1;

    while ((port->tfd & (0x80 | 0x08)));

    port->ci = 1 << slot;

    while (true) {
        
        if ((port->ci & (1 << slot)) == 0)
            break;

		if (port->is & (1 << 30))	// Task file error
			return -1;
    }
    return 0;
}
void ahci_init_dev(int dev) {

    struct ahci_hba_port_struct* port = ahci_devs[dev].port;
    int slot = ahci_find_free_slot(port);

    if (slot == -1)
        return;

    port->is = 0;
    
    struct ahci_command_header* header = &(ahci_devs[dev].command_headers[slot]);
    struct ahci_command_table*  table  = &(ahci_devs[dev].command_tables[slot]);
    void* tx_fis = ahci_devs[dev].tx_fis[slot];
    void* rx_fis = ahci_devs[dev].rx_fis;

    memset((void*)table, 0, sizeof(struct ahci_command_table));

    header->cfl   = sizeof(struct ahci_fis_h2d)/sizeof(uint32_t);
    header->w     = 0;
    header->prdtl = 1;

	memset(table, 0, sizeof(struct ahci_command_table));

    table->prdt[0].dba = (uint64_t)0x100000;
    table->prdt[0].dbc = 511;
    table->prdt[0].i   = 1;

    struct ahci_fis_h2d* cmd = (struct ahci_fis_h2d*)tx_fis;
    cmd->fis_type = AHCI_FIS_TYPE_REG_H2D;
    cmd->c        =    1;
    cmd->command  = 0xED;

    cmd->lba0 = 0;
    cmd->lba1 = 0;
    cmd->lba2 = 0;
    cmd->device = 0;
    
    cmd->lba3 = 0;
    cmd->lba4 = 0;
    cmd->lba5 = 0;

	cmd->countl = 0;
	cmd->counth = 0;

    ahci_wait_for_completion(dev, slot);
    
    write_debug("trn: 0x%s\n", (size_t)header->prdtl, 16);
}

void ahci_find_devs() {

    uint32_t pi = ahci_hba->pi;
    uint16_t ret;

    ahci_dev_amount = 0;

    for (int i = 0; i < 32; i++) {

        if (!(pi & (1 << i)))
            continue;

        if ((i + 1) > ahci_dev_amount)
            ahci_dev_amount = i + 1;

        void* offsetv = ahci_common + (0x2000 * i);
        void* offsetp = mempg_paddr(ahci_common, NULL) + (0x2000 * i);
        ret = ahci_probe_port(&(ahci_hba->ports[i]));

        if (ret == AHCI_DEV_NULL)
            stop_cmd(&(ahci_hba->ports[i]));

        ahci_devs[i].type   = ret;
        ahci_devs[i].rx_fis = offsetv + 0x400;
        ahci_devs[i].port   = (struct ahci_hba_port_struct*)&(ahci_hba->ports[i]);
        //ahci_devs[i].data = offset + 0x4000;

        ahci_devs[i].command_headers = (struct ahci_command_header*)offsetv;
        ahci_devs[i].command_tables  = (struct ahci_command_table*) offsetv + 0x1000;

        void* tbl_ptr;

        for (int j = 0; j < 32; j++) {
            ahci_devs[i].command_headers[j].prdtl = 1;
            ahci_devs[i].command_headers[j].ctba  = (size_t)((offsetp + 0x1000) + (j * sizeof(struct ahci_command_table)));

            ahci_devs[i].tx_fis[j] = ((offsetv + 0x1000) + (j * sizeof(struct ahci_command_table)));

            if (i == 0 && j == 0) {
                write_debug("hdr_init: %s\n", (size_t)&(ahci_devs[i].command_headers[j]) & 0xFFFFFFFFFFFF, 16);
                write_debug("fis_init: %s\n", (size_t)(offsetv + 0x1000) & 0xFFFFFFFFFFFF, 16);
            }

            memset(((offsetv + 0x1000) + (j * sizeof(struct ahci_command_table))), 0, sizeof(struct ahci_command_table));
        }

        //write_debug("phys: %s\n", (size_t)offsetp & 0xFFFFFFFFFFFF, 16);

        ahci_hba->ports[i].clb = (size_t)offsetp;
        ahci_hba->ports[i].fb  = (size_t)offsetp + 0x400;

        if (ret == AHCI_DEV_NULL)
            start_cmd(&(ahci_hba->ports[i]));

        switch (ret) {
            case AHCI_DEV_SATA:
                ahci_init_dev(i);

                write_debug("%s: SATA\n", i, 10);
                break;
            case AHCI_DEV_SATAPI:
                write_debug("%s: SATAPI\n", i, 10);
                break;
            case AHCI_DEV_SEMB:
                write_debug("%s: SEMB\n", i, 10);
                break;
            case AHCI_DEV_PM:
                write_debug("%s: PM\n", i, 10);
                break;

            default:
            case AHCI_DEV_NULL:
                write_debug("%s: Not found\n", i, 10);
                break;
        }
    }
}

int ahci_find_free_slot(struct ahci_hba_port_struct* port) {

    uint32_t busy = port->sact | port->ci;

    for (int i = 0; i < ahci_max_commands; i++)
        if (!(busy & (1 << i)))
            return i;

    printf("No free slot\n");
    return -1;
}

int ahci_write_sector(int dev, uint64_t sector, char* bytes) {
    //write_debug("0x%s\n", (size_t)((void*)(ahci_devs[dev].port)) & 0xFFFFFFFFFFFF, 16);
    //write_debug("0x%s\n", ahci_devs[dev].port->clb, 16);
    struct ahci_hba_port_struct* port = ahci_devs[dev].port;
    int slot = ahci_find_free_slot(port);

    write_debug("%s\n", slot, 10);

    if (slot == -1)
        return -1;

    port->is = 0;
    
    struct ahci_command_header* header = &(ahci_devs[dev].command_headers[slot]);
    struct ahci_command_table*  table  = &(ahci_devs[dev].command_tables[slot]);
    void* tx_fis = ahci_devs[dev].tx_fis[slot];
    void* rx_fis = ahci_devs[dev].rx_fis;

    memset((void*)table, 0, sizeof(struct ahci_command_table));

    header->cfl   = sizeof(struct ahci_fis_h2d)/sizeof(uint32_t);
    header->w     = 1;
    header->prdtl = 1;

    write_debug("tbl   : 0x%s\n", (size_t)table & 0xFFFFFFFFFFFF, 16);
    write_debug("tx_fis: 0x%s\n", (size_t)tx_fis & 0xFFFFFFFFFFFF, 16);
    write_debug("header: 0x%s\n", (size_t)header->ctba & 0xFFFFFFFFFFFF, 16);

	memset(table, 0, sizeof(struct ahci_command_table));

    table->prdt[0].dba = (uint64_t)0x100000;
    table->prdt[0].dbc = 511;
    table->prdt[0].i   = 1;

    struct ahci_fis_h2d* cmd = (struct ahci_fis_h2d*)tx_fis;
    cmd->fis_type = AHCI_FIS_TYPE_REG_H2D;
    cmd->c        =    1;
    cmd->command  = 0x35;

    cmd->lba0 = (uint8_t)sector;
    cmd->lba1 = (uint8_t)(sector >> 8);
    cmd->lba2 = (uint8_t)(sector >> 16);
    cmd->device = 1 << 6;
    
    cmd->lba3 = (uint8_t)(sector >> 24);
    cmd->lba4 = (uint8_t)(sector >> 32);
    cmd->lba5 = (uint8_t)(sector >> 40);

	cmd->countl = 1;
	cmd->counth = 0;

    while ((port->tfd & (0x80 | 0x08)));

    port->ci = 1 << slot;
    
    //write_debug("val: 0x%s\n", *((uint8_t*)tx_fis), 16);
    write_debug("trn: 0x%s\n", (size_t)header->prdtl, 16);

    while (true) {
        
        if ((port->ci & (1 << slot)) == 0)
            break;

		if (port->is & (1 << 30))	// Task file error
		{
			printf("Write disk error\n");
			return -1;
		}
        write_debug("0x%s\n", port->is, 16);
    }
    write_debug("0x%s\n", port->is, 16);
    write_debug("val: 0x%s\n", ((uint8_t*)rx_fis)[0], 16);
    write_debug("trn: 0x%s\n", (size_t)header->prdtl, 16);

    return -1;
}

void ahci_init() {
    printf("Initializing AHCI\n");

    ahci_controller = pci_find_first_by_class_subclass(0x01, 0x06);

    if (ahci_controller == NULL) {
        printf("No AHCI controller found\n\n");
        return;
    }

    ahci_address = ahci_controller->address;

    pci_setup_entry(ahci_controller);

    ahci_bar = ahci_controller->bar[5].virtual_addr;
    write_debug("AHCI ABAR V: 0x%s\n", (size_t)ahci_bar & 0xFFFFFFFFFFFF, 16);
    write_debug("AHCI ABAR P: 0x%s\n", (size_t)ahci_controller->bar[5].physical_addr & 0xFFFFFFFFFFFF, 16);

    ahci_max_commands = ((ahci_hba->cap >> 8) & 0b11111) + 1;

    //write_debug("hdr_init: %s\n", (size_t)&(ahci_devs[i].command_headers[j]) & 0xFFFFFFFFFFFF, 16);

    ahci_hba = (struct ahci_hba_struct*)ahci_bar;
    write_debug("slots : %s\n", ahci_max_commands, 10);
    write_debug("pi    : 0b%s\n", ahci_hba->pi, 2);

    ahci_count_devs();
    ahci_common = mempg_next_contiguous(ahci_dev_amount * 2, NULL, NULL, 0x13);

    memset(ahci_common, 0, ahci_dev_amount * CPU_PAGE_SIZE * 2);
    ahci_find_devs();

    //ahci_write_sector(0, 0, "xdddddddddd");
    write_debug("boi : 0x%s\n", ((uint8_t*)0x100000)[0], 16);

    printf("\n");
}