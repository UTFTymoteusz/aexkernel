
    

    

    struct ahci_fis_h2d* fis = (struct ahci_fis_h2d*)ahci_devs[dev].tx_fis[slot];
    memset((void*)fis, 0, sizeof(struct ahci_fis_h2d));
    fis->fis_type = AHCI_FIS_TYPE_REG_H2D;
    fis->command  = 0xEC;
    fis->c        = 1;
    fis->device   = 0;

    //volatile uint8_t* buff = (uint8_t*)ahci_devs[dev].rx_fis;
    //write_debug("is 0x%s\n", port->is, 16);

    while (port->tfd & (ATA_DEV_BUSY | ATA_DEV_DRQ));

    port->ie  |= 1 << slot;
    port->ci  |= 1 << slot;
    
    write_debug("dma 0x%s\n", ((uint8_t*)ahci_devs[dev].dma)[83], 16);
    write_debug("dmac %s\n", header->prdbc, 10);

    while (true) {

		if ((port->ci & (1 << slot)) == 0) 
			break;

        //write_debug("ssts 0x%s\n", port->ssts, 16);
        //write_debug("sctl 0x%s\n", port->sctl, 16);
        //write_debug("serr 0x%s\n", port->serr, 16);
        //write_debug("sact 0x%s\n", port->sact, 16);

        write_debug("is 0x%s\n", port->is, 16);
        sleep(500);
    }

    write_debug("dma  0x%s\n", ((uint8_t*)ahci_devs[dev].dma)[83], 16);
    write_debug("dmac %s\n", header->prdbc, 10);
    write_debug("is 0x%s\n", port->is, 16);


    int slot = ahci_find_free_slot(port);
    

    struct ahci_command_header* header = &(ahci_devs[dev].command_headers[slot]);
    memset((void*)header, 0, sizeof(struct ahci_command_header));